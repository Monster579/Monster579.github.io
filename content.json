{"meta":{"title":null,"subtitle":null,"description":null,"author":"我说我不会","url":"https://monster579.github.io","root":"/"},"pages":[{"title":"tags","date":"2019-03-14T09:16:20.000Z","updated":"2019-08-19T07:18:35.953Z","comments":false,"path":"tags/index.html","permalink":"https://monster579.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-03-14T09:16:47.000Z","updated":"2019-08-19T07:18:31.370Z","comments":false,"path":"categories/index.html","permalink":"https://monster579.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"单例模式","slug":"单例模式","date":"2019-09-05T10:58:27.000Z","updated":"2019-09-16T06:38:24.664Z","comments":true,"path":"2019/09/05/单例模式/","link":"","permalink":"https://monster579.github.io/2019/09/05/单例模式/","excerpt":"","text":"单例模式1.何为单例单例模式在我们的程序设计中很常见，比如我们常用的Spring创建bean对象时就是对单例模式很好的诠释。单例模式可节约系统内存空间，控制资源的使用,避免对象的重复创建。其中单例模式最重要的是确保对象只有一个.其实单例模式就是保证对象只有一个，单例同时也分为饿汉和懒汉模式。 2.单例的实现1). 饿汉式为什么叫饿汉呢，就是说很饿什么都吃，所以在调用单例类之前就已经加载了这个类。一般情况下在调用getInstance方法之前就已经产生了实例，也就是在类加载的时候已经产生了实例。饿汉模式的缺点很明显，就是占用系统资源，当一个单例类很大的时候，我们在一开始就切加载这个类，之后整个系统都会因为加载这个类，而增加启动时间，这种方式适合占用资源少，在初始化的时候就会被用到的类，比如Spring中初始加载的bean对象。 123456789101112public class Singleton &#123; private static Singleton s = new Singleton(); private Singleton()&#123; &#125; public static Singleton getInstance()&#123; return s; &#125;&#125; 2). 懒汉式懒汉顾名思义就是懒，好比牙膏挤一点出一点，当我们去使用它的时候他才会去动。这种模式就是懒加载模式，当我们去使用的时候才去加载，这样可以提升内存利用率。 12345678910111213141516public class SingletonLazy &#123; private static SingletonLazy singletonLazy ; private SingletonLazy()&#123; &#125; public static synchronized SingletonLazy getInstance()&#123; if(singletonLazy == null)&#123; singletonLazy = new SingletonLazy(); &#125; return singletonLazy; &#125;&#125; static与单例我们发现无论是饿汉还是懒汉，都有一个静态的类变量，以及一个静态的getInstance方法，那么为什么要用static呢？static关键字修饰的无论是方法变量还是特定的块，都是在初始化时就已经加载了。有一个很重要的原因，是因为static具有唯一性，这个唯一性的限定来自于JVM，这正好符合我们单例的要求，对于单例来说我们需要只存在一个可用的类，且在一开始初始化的时候就加载，并在后面进行特定限制保证只有一个实例。这样可能会出现线程安全的问题，所以我们通过同步锁机制（懒汉模式）解决线程安全问题。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://monster579.github.io/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://monster579.github.io/tags/设计模式/"},{"name":"单例","slug":"单例","permalink":"https://monster579.github.io/tags/单例/"}]},{"title":"==,equals与hashcode","slug":"equals与hashcode","date":"2019-08-20T10:49:24.000Z","updated":"2019-09-09T06:38:36.200Z","comments":true,"path":"2019/08/20/equals与hashcode/","link":"","permalink":"https://monster579.github.io/2019/08/20/equals与hashcode/","excerpt":"","text":"个人对“==”,equals与hashCode的理解1.== 和 equals判断相等通常我们回使用 == 和 equals去判断，而在使用的时候会发现二者使用的对象有所差异。 下面进行讨论 String，基本数据类型（int，long，……），引用类型 先看一段代码（String） 1234String str1 = &quot;123&quot;;String str2 = new String(&quot;123&quot;);System.out.println(str1 == str2); // --- falseSystem.out.println(str1.equals(str2)); // --- true == 用来比较内存空间，即就是字符串的空间是否为同一个，并且空间内的值是否一致。 equals 则是用来比较String内容是否相同，我们可以挺过查看java.lang.String类的equals方法可以看出，equals只是比较两个String的值是否相同 123456789101112131415161718192021public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; 基本数据类型 我们平时对于基本数据类型进行判断只是判断他们的数值是否相等。 引用类型1234Integer int1 = new Integer(1);Integer int2 = new Integer(1);System.out.println(int1 == int2); // fasleSystem.out.println(int1.equals(int2)); // true equals比较的是地址空间是否相同，也就是栈的内容，那么这里equals方法比较之后也应该为false，但是最后返回的事true，这是因为在Integer中，对equals方法进行了重写。如同上面String也是比较内容，String也是对equals方法进行了重写。 无论是==还是equals比较的都是栈中的内容，即对象的引用，也就是比较的是两个对象的地址，所以一旦新建，或者变为了新的对象时，== 与 equals都会返回false，但是为了我们的使用方便，java的引用类型都对equals方法进行了重写，只比较栈所对应堆的内容是否相同，也就是对象的内容是否相同。 2.equals与hashcode我们在读源码时会发现，无论是String，还是Integer都在重写equals时重写了hashcode，那么他们两者是什么关系呢？一般对于一个Object类来说java有以下两个规范， 规范1：若重写equals(Object obj)方法，有必要重写hashcode()方法，确保通过equals(Object obj)方法判断结果为true的两个对象具备相等的hashcode()返回值。说得简单点就是：“如果两个对象相同，那么他们的hashcode应该 相等”。 规范2：如果equals(Object obj)返回false，即两个对象“不相同”，并不要求对这两个对象调用hashcode()方法得到两个不相同的数。说的简单点就是：“如果两个对象不相同，他们的hashcode可能相同”。 根据这两个规范，可以得到如下推论： 1、如果两个对象equals，Java运行时环境会认为他们的hashcode一定相等。 2、如果两个对象不equals，他们的hashcode有可能相等。 3、如果两个对象hashcode相等，他们不一定equals。 4、如果两个对象hashcode不相等，他们一定不equals 根据以上可以得出：我们在重写equals时最好同时重写HashCode方法，这样可以使得类更完善。 ps：hashcode方法其实是java的本地方法，也就是说返回此类的栈地址，也就是返回一个地址，而对于集合中的hash类型时，hashcode方法为：key值与value值进行 ^（异或） 运算 HashMap.java1234hashMap 中的hashCode方法public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; Objects.java123public static int hashCode(Object o) &#123; return o != null ? o.hashCode() : 0; &#125;","categories":[{"name":"java","slug":"java","permalink":"https://monster579.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://monster579.github.io/tags/java基础/"}]},{"title":"javs八大基本数据类型","slug":"javsa八大基本数据类型","date":"2019-08-19T09:41:28.000Z","updated":"2019-09-09T05:50:59.635Z","comments":true,"path":"2019/08/19/javsa八大基本数据类型/","link":"","permalink":"https://monster579.github.io/2019/08/19/javsa八大基本数据类型/","excerpt":"","text":"名称 数据类型 字节大小 所占bit int 整型 4 32 short 短整型 2 16 long 长整型 8 64 double 双精度 8 64 float 浮点数 4 32 char 字符型 2 16 byte 字节 1 8 boolean 布尔型 1 8(只有第一位表示正负，其余7位全为0)","categories":[{"name":"java","slug":"java","permalink":"https://monster579.github.io/categories/java/"}],"tags":[{"name":"java基础","slug":"java基础","permalink":"https://monster579.github.io/tags/java基础/"}]},{"title":"数据库索引","slug":"数据库索引","date":"2019-07-07T12:35:45.000Z","updated":"2019-09-03T14:45:33.232Z","comments":true,"path":"2019/07/07/数据库索引/","link":"","permalink":"https://monster579.github.io/2019/07/07/数据库索引/","excerpt":"","text":"索引1为了快速查询数据库数据引入索引概念，添加字段索引可以有效地加快查询速度 1. 索引简述在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容 — 来自百度百科 我的理解数据库其实是一种文件，而索引类似于一个目录，更抽象的说可以理解为一个汉语字典，字典A-Z排序，每次通过索引查找就好比知道了我们需要查找的汉字的首拼，之后通过首字母匹配能快速匹配到单词所在的具体区间，从而快速的找到符合条件的数据。 索引是引入了一种数据结构（mysql 是 BTREE 和 HASH），对建立了索引的字段用此数据结构存储，每次查询是都可以通过算法快速的查找。 而索引也分为了聚集索引和非聚集索引。 2. 聚集索引聚集索引一般为主键，类似分区，树状数据结构，逻辑顺序排序。因此一旦设定数据库主键则确定了一个索引，也可以反推出主键必须为int。若没有指定主键，则聚集索引可以是任意一列，但是最好选择int类型，若为string可能会出现问题 3. 非聚集索引非聚集索引有，普通索引 唯一索引 全文索引。非聚集索引类似于字典按部首去查，这是会先把整个顺序排出来，再按照检字表对应的页码查找。物理存储不按照索引排序；非聚集索引则就是普通索引了，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序。特殊情况下，可以设定两个索引联合，形成覆盖索引会相对聚集索引更快。 1索引是通过二叉树的数据结构来描述的，我们可以这么理解聚集索引：索引的叶节点就是数据节点。而非聚集索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。 未完待更…","categories":[{"name":"mysql","slug":"mysql","permalink":"https://monster579.github.io/categories/mysql/"}],"tags":[{"name":"索引","slug":"索引","permalink":"https://monster579.github.io/tags/索引/"}]},{"title":"mysql UNIQUE唯一约束","slug":"mysql-UNIQUE唯一约束","date":"2019-07-04T13:20:00.000Z","updated":"2019-09-03T14:43:19.246Z","comments":true,"path":"2019/07/04/mysql-UNIQUE唯一约束/","link":"","permalink":"https://monster579.github.io/2019/07/04/mysql-UNIQUE唯一约束/","excerpt":"","text":"mysql数据库添加唯一约束 唯一约束与主键的关系 主键：不能为空 一张表只能有一个主键 唯一约束： 可以为null值 可以有多个唯一约束 创建表如下 12345678CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(40) CHARACTER SET latin1 DEFAULT NULL, `password` varchar(40) CHARACTER SET latin1 DEFAULT NULL, `email` varchar(60) CHARACTER SET latin1 DEFAULT NULL, `birthday` date DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8; 两种建立方式 建表时建立 1`name` varchar(40) CHARACTER SET latin1 DEFAULT NULL unique, 后续添加 1alter table `user` add UNIQUE(name) 查看唯一约束1show keys from `user` ZenshT.png 删除唯一约束1drop index name on user;","categories":[{"name":"mysql","slug":"mysql","permalink":"https://monster579.github.io/categories/mysql/"}],"tags":[{"name":"索引","slug":"索引","permalink":"https://monster579.github.io/tags/索引/"}]},{"title":"show index 字段描述","slug":"show-index-字段描述","date":"2019-07-03T14:37:22.000Z","updated":"2019-09-09T03:09:31.992Z","comments":true,"path":"2019/07/03/show-index-字段描述/","link":"","permalink":"https://monster579.github.io/2019/07/03/show-index-字段描述/","excerpt":"","text":"通常我们建立索引之后会出现一些性能使用的问题，因此我们通过show index 命令查看索引的具体详细，帮助我们解决问题 数据库建立索引 通过show index from tableName 获得如下的字段参数 字段.png 各个字段参数如下1.Table 表的名称。 2.Non_unique 如果索引不能包括重复词，则为0。如果可以，则为1。 3.Key_name 索引的名称。 4.Seq_in_index 索引中的列序列号，从1开始。 5.Column_name 列名称。 6.Collation 列以什么方式存储在索引中。在MySQL中，有值‘A’（升序）或NULL（无分类）。 7.Cardinality 索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL使用该索引的机会就越大。 8.Sub_part 如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。 9.Packed 指示关键字如何被压缩。如果没有被压缩，则为NULL。 10.Null 如果列含有NULL，则含有YES。如果没有，则该列含有NO。 11.Index_type 用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）。 12.Comment 多种评注。 13.Index_comment 索引描述 14.Visible 是否可用","categories":[{"name":"mysql","slug":"mysql","permalink":"https://monster579.github.io/categories/mysql/"}],"tags":[{"name":"索引","slug":"索引","permalink":"https://monster579.github.io/tags/索引/"}]},{"title":"jpa Specification","slug":"jpa-Specification","date":"2019-05-18T14:51:34.000Z","updated":"2019-09-03T14:52:47.018Z","comments":true,"path":"2019/05/18/jpa-Specification/","link":"","permalink":"https://monster579.github.io/2019/05/18/jpa-Specification/","excerpt":"","text":"使用jpa的Specification 实现动态复杂查询条件当遇到同时需要多个限制条件共同生效来查询数据时，每一次传入的参数不固定，也就是多个查询条件查询时不会传入每一个查询条件。解决时可以通过参数进行传递，此时可以变更request参数属性 （required 为 false） 但这样效率不高，requestParam会有很多写起来也很杂乱，sql写起来也会很长。因此使用Specification实现上述要求。 创建查询条件1234567Specification&lt;UserInfo&gt; specification = new Specification&lt;UserInfo&gt;() &#123; @Override public Predicate toPredicate(Root&lt;UserInfo&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) &#123; return null; &#125; &#125;; 参数说明 Root：查询哪个表 CriteriaQuery：查询哪些字段，排序是什么 CriteriaBuilder：字段之间是什么关系，如何生成一个查询条件，每一个查询条件都是什么方式 Predicate（Expression）：单独每一条查询条件的详细描述 运用Lambda 表达式(简化内部类的生成)简化如下12345678Specification&lt;UserProduct&gt; specification =(root,cq,cb) -&gt; &#123; List&lt;Predicate&gt; list = new ArrayList&lt;&gt;(); list.add(cb.equal(root.get(&quot;condition.XXX&quot;),10)); // root 为具体对象 equal(数据库字段，查询条件（Object）) list.add(cb.or()); list.add(cb.like()); ... return cb.and(list.toArray(new Predicate[list.size()])); &#125;; 当需要加入其它表的时候需要1Join&lt;Object,Object&gt; userInfo = root.join(&quot;userInfo&quot;);","categories":[{"name":"java","slug":"java","permalink":"https://monster579.github.io/categories/java/"}],"tags":[{"name":"jpa","slug":"jpa","permalink":"https://monster579.github.io/tags/jpa/"}]},{"title":"一个程序的运行流程","slug":"一个程序的运行流程","date":"2019-04-03T14:40:00.000Z","updated":"2019-09-03T14:45:52.281Z","comments":true,"path":"2019/04/03/一个程序的运行流程/","link":"","permalink":"https://monster579.github.io/2019/04/03/一个程序的运行流程/","excerpt":"","text":"一个程序的运行过程 在某个地方看见如下的一个程序12345678910111213141516171819202122232425262728293031323334353637383940public class Test &#123; public static void main(String [] args)&#123; System.out.println(new B().getValue()); &#125; static class A&#123; protected int value; public A(int v)&#123; setValue(v); &#125; public void setValue(int v)&#123; this.value = v; &#125; public int getValue()&#123; try&#123; value++; return value; 的return; &#125; catch(Exception e) &#123; System.out.println(e.toString()); &#125; finally &#123; this.setValue(value); System.out.println(value); &#125; return value; &#125; &#125; static class B extends A&#123; public B()&#123; super(5); setValue(getValue() - 3); &#125; public void setValue(int v)&#123; super.setValue(2*v); &#125; &#125;&#125; 程序最终将会输出什么? newB().getValue() 创建B对象 同时调用B对象的构造方法来创建B对象 super(5)调用父类的构造方法 B有对set方法的重写 v = 10 setValue(getValue() - 3) 由于B没有get方法 调用A的get方法 先++ 得到 v = 11 返回此时的v值（即存入临时栈中） 执行finally块 调用B的set 得到 v = 22 输出 执行get - 3 此时的v值为之前return的值 也就是 11 得到 v = 8 执行B的set 得到 v = 16 执行main 新建B对象的 get 方法 也就是B父类的get方法 ++得到 v = 17 同样return存入临时栈 执行finally块 v = 34 输出 打印main函数 v = 17 输出","categories":[{"name":"java","slug":"java","permalink":"https://monster579.github.io/categories/java/"}],"tags":[{"name":"java程序","slug":"java程序","permalink":"https://monster579.github.io/tags/java程序/"}]},{"title":"Spring IOC 与 DI","slug":"Spring-IOC-与-DI","date":"2019-01-03T15:00:21.000Z","updated":"2019-09-03T15:04:22.240Z","comments":true,"path":"2019/01/03/Spring-IOC-与-DI/","link":"","permalink":"https://monster579.github.io/2019/01/03/Spring-IOC-与-DI/","excerpt":"","text":"Spring 的IOC与DI分享Bromon的blog上对IoC与DI浅显易懂的讲解1、IoC(控制反转) 首先想说说IoC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。 那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。 2、DI(依赖注入) IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。 我对IOC与DI的理解IOC 控制反转，是Spring提供的一个工厂，我们将项目的对象提前创建好（有时是需要的时候才创建），每次需要使用对象时，调用方不用自主生成对象，而是将控制权交给了Spring容器 DI 依赖注入 就是在Spring创建对象的时候将对象属性依赖进去，不用再次的去对每个属性设置值。","categories":[{"name":"spring","slug":"spring","permalink":"https://monster579.github.io/categories/spring/"}],"tags":[{"name":"IOC","slug":"IOC","permalink":"https://monster579.github.io/tags/IOC/"}]}]}