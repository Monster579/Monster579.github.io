{"meta":{"title":null,"subtitle":null,"description":null,"author":"我说我不会","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-03-14T09:16:47.000Z","updated":"2019-08-19T07:18:31.370Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-14T09:16:20.000Z","updated":"2019-08-19T07:18:35.953Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"数据库索引","slug":"数据库索引","date":"2019-07-07T12:35:45.000Z","updated":"2019-09-03T14:45:33.232Z","comments":true,"path":"2019/07/07/数据库索引/","link":"","permalink":"http://yoursite.com/2019/07/07/数据库索引/","excerpt":"","text":"索引1为了快速查询数据库数据引入索引概念，添加字段索引可以有效地加快查询速度 1. 索引简述在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容 — 来自百度百科 我的理解数据库其实是一种文件，而索引类似于一个目录，更抽象的说可以理解为一个汉语字典，字典A-Z排序，每次通过索引查找就好比知道了我们需要查找的汉字的首拼，之后通过首字母匹配能快速匹配到单词所在的具体区间，从而快速的找到符合条件的数据。 索引是引入了一种数据结构（mysql 是 BTREE 和 HASH），对建立了索引的字段用此数据结构存储，每次查询是都可以通过算法快速的查找。 而索引也分为了聚集索引和非聚集索引。 2. 聚集索引聚集索引一般为主键，类似分区，树状数据结构，逻辑顺序排序。因此一旦设定数据库主键则确定了一个索引，也可以反推出主键必须为int。若没有指定主键，则聚集索引可以是任意一列，但是最好选择int类型，若为string可能会出现问题 3. 非聚集索引非聚集索引有，普通索引 唯一索引 全文索引。非聚集索引类似于字典按部首去查，这是会先把整个顺序排出来，再按照检字表对应的页码查找。物理存储不按照索引排序；非聚集索引则就是普通索引了，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序。特殊情况下，可以设定两个索引联合，形成覆盖索引会相对聚集索引更快。 1索引是通过二叉树的数据结构来描述的，我们可以这么理解聚集索引：索引的叶节点就是数据节点。而非聚集索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。 未完待更…","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"}],"tags":[{"name":"索引","slug":"索引","permalink":"http://yoursite.com/tags/索引/"}]},{"title":"mysql UNIQUE唯一约束","slug":"mysql-UNIQUE唯一约束","date":"2019-07-04T13:20:00.000Z","updated":"2019-09-03T14:43:19.246Z","comments":true,"path":"2019/07/04/mysql-UNIQUE唯一约束/","link":"","permalink":"http://yoursite.com/2019/07/04/mysql-UNIQUE唯一约束/","excerpt":"","text":"mysql数据库添加唯一约束 唯一约束与主键的关系 主键：不能为空 一张表只能有一个主键 唯一约束： 可以为null值 可以有多个唯一约束 创建表如下 12345678CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(40) CHARACTER SET latin1 DEFAULT NULL, `password` varchar(40) CHARACTER SET latin1 DEFAULT NULL, `email` varchar(60) CHARACTER SET latin1 DEFAULT NULL, `birthday` date DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8; 两种建立方式 建表时建立 1`name` varchar(40) CHARACTER SET latin1 DEFAULT NULL unique, 后续添加 1alter table `user` add UNIQUE(name) 查看唯一约束1show keys from `user` ZenshT.png 删除唯一约束1drop index name on user;","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"}],"tags":[{"name":"索引","slug":"索引","permalink":"http://yoursite.com/tags/索引/"}]},{"title":"show index 字段描述","slug":"show-index-字段描述","date":"2019-07-03T14:37:22.000Z","updated":"2019-09-03T14:43:04.641Z","comments":true,"path":"2019/07/03/show-index-字段描述/","link":"","permalink":"http://yoursite.com/2019/07/03/show-index-字段描述/","excerpt":"","text":"通常我们建立索引之后会出现一些性能使用的问题，因此我们通过show index 命令查看索引的具体详细，帮助我们解决问题 数据库建立索引 通过show index from tableName 获得如下的字段参数 [ m8fgjP.png](https://s2.ax1x.com/2019/08/20/m8fgjP.png) 各个字段参数如下1.Table 表的名称。 2.Non_unique 如果索引不能包括重复词，则为0。如果可以，则为1。 3.Key_name 索引的名称。 4.Seq_in_index 索引中的列序列号，从1开始。 5.Column_name 列名称。 6.Collation 列以什么方式存储在索引中。在MySQL中，有值‘A’（升序）或NULL（无分类）。 7.Cardinality 索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL使用该索引的机会就越大。 8.Sub_part 如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。 9.Packed 指示关键字如何被压缩。如果没有被压缩，则为NULL。 10.Null 如果列含有NULL，则含有YES。如果没有，则该列含有NO。 11.Index_type 用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）。 12.Comment 多种评注。 13.Index_comment 索引描述 14.Visible 是否可用","categories":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/categories/mysql/"}],"tags":[{"name":"索引","slug":"索引","permalink":"http://yoursite.com/tags/索引/"}]},{"title":"jpa Specification","slug":"jpa-Specification","date":"2019-05-18T14:51:34.000Z","updated":"2019-09-03T14:52:47.018Z","comments":true,"path":"2019/05/18/jpa-Specification/","link":"","permalink":"http://yoursite.com/2019/05/18/jpa-Specification/","excerpt":"","text":"使用jpa的Specification 实现动态复杂查询条件当遇到同时需要多个限制条件共同生效来查询数据时，每一次传入的参数不固定，也就是多个查询条件查询时不会传入每一个查询条件。解决时可以通过参数进行传递，此时可以变更request参数属性 （required 为 false） 但这样效率不高，requestParam会有很多写起来也很杂乱，sql写起来也会很长。因此使用Specification实现上述要求。 创建查询条件1234567Specification&lt;UserInfo&gt; specification = new Specification&lt;UserInfo&gt;() &#123; @Override public Predicate toPredicate(Root&lt;UserInfo&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) &#123; return null; &#125; &#125;; 参数说明 Root：查询哪个表 CriteriaQuery：查询哪些字段，排序是什么 CriteriaBuilder：字段之间是什么关系，如何生成一个查询条件，每一个查询条件都是什么方式 Predicate（Expression）：单独每一条查询条件的详细描述 运用Lambda 表达式(简化内部类的生成)简化如下12345678Specification&lt;UserProduct&gt; specification =(root,cq,cb) -&gt; &#123; List&lt;Predicate&gt; list = new ArrayList&lt;&gt;(); list.add(cb.equal(root.get(&quot;condition.XXX&quot;),10)); // root 为具体对象 equal(数据库字段，查询条件（Object）) list.add(cb.or()); list.add(cb.like()); ... return cb.and(list.toArray(new Predicate[list.size()])); &#125;; 当需要加入其它表的时候需要1Join&lt;Object,Object&gt; userInfo = root.join(&quot;userInfo&quot;);","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"jpa","slug":"jpa","permalink":"http://yoursite.com/tags/jpa/"}]},{"title":"一个程序的运行流程","slug":"一个程序的运行流程","date":"2019-04-03T14:40:00.000Z","updated":"2019-09-03T14:45:52.281Z","comments":true,"path":"2019/04/03/一个程序的运行流程/","link":"","permalink":"http://yoursite.com/2019/04/03/一个程序的运行流程/","excerpt":"","text":"一个程序的运行过程 在某个地方看见如下的一个程序12345678910111213141516171819202122232425262728293031323334353637383940public class Test &#123; public static void main(String [] args)&#123; System.out.println(new B().getValue()); &#125; static class A&#123; protected int value; public A(int v)&#123; setValue(v); &#125; public void setValue(int v)&#123; this.value = v; &#125; public int getValue()&#123; try&#123; value++; return value; 的return; &#125; catch(Exception e) &#123; System.out.println(e.toString()); &#125; finally &#123; this.setValue(value); System.out.println(value); &#125; return value; &#125; &#125; static class B extends A&#123; public B()&#123; super(5); setValue(getValue() - 3); &#125; public void setValue(int v)&#123; super.setValue(2*v); &#125; &#125;&#125; 程序最终将会输出什么? newB().getValue() 创建B对象 同时调用B对象的构造方法来创建B对象 super(5)调用父类的构造方法 B有对set方法的重写 v = 10 setValue(getValue() - 3) 由于B没有get方法 调用A的get方法 先++ 得到 v = 11 返回此时的v值（即存入临时栈中） 执行finally块 调用B的set 得到 v = 22 输出 执行get - 3 此时的v值为之前return的值 也就是 11 得到 v = 8 执行B的set 得到 v = 16 执行main 新建B对象的 get 方法 也就是B父类的get方法 ++得到 v = 17 同样return存入临时栈 执行finally块 v = 34 输出 打印main函数 v = 17 输出","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"}],"tags":[{"name":"java程序","slug":"java程序","permalink":"http://yoursite.com/tags/java程序/"}]},{"title":"Spring IOC 与 DI","slug":"Spring-IOC-与-DI","date":"2019-01-03T15:00:21.000Z","updated":"2019-09-03T15:04:22.240Z","comments":true,"path":"2019/01/03/Spring-IOC-与-DI/","link":"","permalink":"http://yoursite.com/2019/01/03/Spring-IOC-与-DI/","excerpt":"","text":"Spring 的IOC与DI分享Bromon的blog上对IoC与DI浅显易懂的讲解1、IoC(控制反转) 首先想说说IoC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。 那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。 2、DI(依赖注入) IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。 我对IOC与DI的理解IOC 控制反转，是Spring提供的一个工厂，我们将项目的对象提前创建好（有时是需要的时候才创建），每次需要使用对象时，调用方不用自主生成对象，而是将控制权交给了Spring容器 DI 依赖注入 就是在Spring创建对象的时候将对象属性依赖进去，不用再次的去对每个属性设置值。","categories":[{"name":"spring","slug":"spring","permalink":"http://yoursite.com/categories/spring/"}],"tags":[{"name":"IOC","slug":"IOC","permalink":"http://yoursite.com/tags/IOC/"}]}]}