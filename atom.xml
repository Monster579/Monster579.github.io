<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title></title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-03T14:45:33.232Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>我说我不会</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库索引</title>
    <link href="http://yoursite.com/2019/07/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2019/07/07/数据库索引/</id>
    <published>2019-07-07T12:35:45.000Z</published>
    <updated>2019-09-03T14:45:33.232Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为了快速查询数据库数据引入索引概念，添加字段索引可以有效地加快查询速度</span><br></pre></td></tr></table></figure><h2 id="1-索引简述"><a href="#1-索引简述" class="headerlink" title="1. 索引简述"></a>1. 索引简述</h2><p>在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容</p><p> — 来自百度百科</p><h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h3><p>数据库其实是一种文件，而索引类似于一个目录，更抽象的说可以理解为一个汉语字典，字典A-Z排序，每次通过索引查找就好比知道了我们需要查找的汉字的首拼，之后通过首字母匹配能快速匹配到单词所在的具体区间，从而快速的找到符合条件的数据。</p><p>索引是引入了一种数据结构（mysql 是 BTREE 和 HASH），对建立了索引的字段用此数据结构存储，每次查询是都可以通过算法快速的查找。</p><p>而索引也分为了聚集索引和非聚集索引。</p><h2 id="2-聚集索引"><a href="#2-聚集索引" class="headerlink" title="2. 聚集索引"></a>2. 聚集索引</h2><p>聚集索引一般为主键，类似分区，树状数据结构，逻辑顺序排序。因此一旦设定数据库主键则确定了一个索引，也可以反推出主键必须为int。若没有指定主键，则聚集索引可以是任意一列，但是最好选择int类型，若为string可能会出现问题</p><h2 id="3-非聚集索引"><a href="#3-非聚集索引" class="headerlink" title="3. 非聚集索引"></a>3. 非聚集索引</h2><p>非聚集索引有，普通索引 唯一索引 全文索引。<br>非聚集索引类似于字典按部首去查，这是会先把整个顺序排出来，再按照检字表对应的页码查找。<br>物理存储不按照索引排序；非聚集索引则就是普通索引了，仅仅只是对数据列创建相应的索引，不影响整个表的物理存储顺序。特殊情况下，可以设定两个索引联合，形成覆盖索引会相对聚集索引更快。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引是通过二叉树的数据结构来描述的，我们可以这么理解聚集索引：索引的叶节点就是数据节点。而非聚集索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。</span><br></pre></td></tr></table></figure><p>未完待更…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;索引&quot;&gt;&lt;a href=&quot;#索引&quot; class=&quot;headerlink&quot; title=&quot;索引&quot;&gt;&lt;/a&gt;索引&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="索引" scheme="http://yoursite.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>mysql UNIQUE唯一约束</title>
    <link href="http://yoursite.com/2019/07/04/mysql-UNIQUE%E5%94%AF%E4%B8%80%E7%BA%A6%E6%9D%9F/"/>
    <id>http://yoursite.com/2019/07/04/mysql-UNIQUE唯一约束/</id>
    <published>2019-07-04T13:20:00.000Z</published>
    <updated>2019-09-03T14:43:19.246Z</updated>
    
    <content type="html"><![CDATA[<h3 id="mysql数据库添加唯一约束"><a href="#mysql数据库添加唯一约束" class="headerlink" title="mysql数据库添加唯一约束"></a>mysql数据库添加唯一约束</h3><blockquote><p>唯一约束与主键的关系<br> 主键：不能为空  一张表只能有一个主键<br> 唯一约束： 可以为null值  可以有多个唯一约束</p></blockquote><p> 创建表如下<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE `user` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `name` varchar(40) CHARACTER SET latin1 DEFAULT NULL,</span><br><span class="line">  `password` varchar(40) CHARACTER SET latin1 DEFAULT NULL,</span><br><span class="line">  `email` varchar(60) CHARACTER SET latin1 DEFAULT NULL,</span><br><span class="line">  `birthday` date DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure></p><p> 两种建立方式 </p><ol><li><p>建表时建立</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`name` varchar(40) CHARACTER SET latin1 DEFAULT NULL unique,</span><br></pre></td></tr></table></figure></li><li><p>后续添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table `user` add UNIQUE(name)</span><br></pre></td></tr></table></figure></li></ol><p>查看唯一约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show keys from `user`</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s2.ax1x.com/2019/06/26/ZenshT.png" alt="ZenshT.png" title>                </div>                <div class="image-caption">ZenshT.png</div>            </figure><p>删除唯一约束<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index name on user;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;mysql数据库添加唯一约束&quot;&gt;&lt;a href=&quot;#mysql数据库添加唯一约束&quot; class=&quot;headerlink&quot; title=&quot;mysql数据库添加唯一约束&quot;&gt;&lt;/a&gt;mysql数据库添加唯一约束&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;唯一约束与主键的关
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="索引" scheme="http://yoursite.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>show index 字段描述</title>
    <link href="http://yoursite.com/2019/07/03/show-index-%E5%AD%97%E6%AE%B5%E6%8F%8F%E8%BF%B0/"/>
    <id>http://yoursite.com/2019/07/03/show-index-字段描述/</id>
    <published>2019-07-03T14:37:22.000Z</published>
    <updated>2019-09-03T14:43:04.641Z</updated>
    
    <content type="html"><![CDATA[<p>通常我们建立索引之后会出现一些性能使用的问题，因此我们通过show index 命令查看索引的具体详细，帮助我们解决问题</p><blockquote><p>数据库建立索引 通过show index from tableName 获得如下的字段参数</p></blockquote><p>[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://imgchr.com/i/m8fgjP" alt="m8fgjP.png](https://s2.ax1x.com/2019/08/20/m8fgjP.png)" title>                </div>                <div class="image-caption">m8fgjP.png](https://s2.ax1x.com/2019/08/20/m8fgjP.png)</div>            </figure></p><h2 id="各个字段参数如下"><a href="#各个字段参数如下" class="headerlink" title="各个字段参数如下"></a>各个字段参数如下</h2><p>1.Table </p><p>表的名称。</p><p>2.Non_unique </p><p>如果索引不能包括重复词，则为0。如果可以，则为1。</p><p>3.Key_name </p><p>索引的名称。</p><p>4.Seq_in_index </p><p>索引中的列序列号，从1开始。</p><p>5.Column_name</p><p>列名称。</p><p>6.Collation</p><p>列以什么方式存储在索引中。在MySQL中，有值‘A’（升序）或NULL（无分类）。</p><p>7.Cardinality </p><p>索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL使用该索引的机会就越大。</p><p>8.Sub_part </p><p>如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。</p><p>9.Packed </p><p>指示关键字如何被压缩。如果没有被压缩，则为NULL。</p><p>10.Null </p><p>如果列含有NULL，则含有YES。如果没有，则该列含有NO。</p><p>11.Index_type </p><p>用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）。</p><p>12.Comment </p><p>多种评注。</p><p>13.Index_comment</p><p>索引描述</p><p>14.Visible</p><p>是否可用</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通常我们建立索引之后会出现一些性能使用的问题，因此我们通过show index 命令查看索引的具体详细，帮助我们解决问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;数据库建立索引 通过show index from tableName 获得如下的字段参数&lt;/p&gt;
&lt;/bloc
      
    
    </summary>
    
      <category term="mysql" scheme="http://yoursite.com/categories/mysql/"/>
    
    
      <category term="索引" scheme="http://yoursite.com/tags/%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>jpa Specification</title>
    <link href="http://yoursite.com/2019/05/18/jpa-Specification/"/>
    <id>http://yoursite.com/2019/05/18/jpa-Specification/</id>
    <published>2019-05-18T14:51:34.000Z</published>
    <updated>2019-09-03T14:52:47.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用jpa的Specification-实现动态复杂查询条件"><a href="#使用jpa的Specification-实现动态复杂查询条件" class="headerlink" title="使用jpa的Specification 实现动态复杂查询条件"></a>使用jpa的Specification 实现动态复杂查询条件</h1><p>当遇到同时需要多个限制条件共同生效来查询数据时，每一次传入的参数不固定，也就是多个查询条件查询时不会传入每一个查询条件。解决时可以通过参数进行传递，此时可以变更request参数属性 （required 为 false） 但这样效率不高，requestParam会有很多写起来也很杂乱，sql写起来也会很长。因此使用Specification实现上述要求。</p><p>创建查询条件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Specification&lt;UserInfo&gt; specification = new Specification&lt;UserInfo&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Predicate toPredicate(Root&lt;UserInfo&gt; root, CriteriaQuery&lt;?&gt; criteriaQuery, CriteriaBuilder criteriaBuilder) &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></p><hr><p>参数说明</p><ul><li>Root：查询哪个表</li><li>CriteriaQuery：查询哪些字段，排序是什么</li><li>CriteriaBuilder：字段之间是什么关系，如何生成一个查询条件，每一个查询条件都是什么方式</li><li>Predicate（Expression）：单独每一条查询条件的详细描述</li></ul><hr><p>运用Lambda 表达式(简化内部类的生成)简化如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Specification&lt;UserProduct&gt; specification =(root,cq,cb) -&gt; &#123;</span><br><span class="line">           List&lt;Predicate&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">           list.add(cb.equal(root.get(&quot;condition.XXX&quot;),10)); // root 为具体对象  equal(数据库字段，查询条件（Object）)</span><br><span class="line">           list.add(cb.or());</span><br><span class="line">           list.add(cb.like());</span><br><span class="line">           ...</span><br><span class="line">           return cb.and(list.toArray(new Predicate[list.size()]));</span><br><span class="line">       &#125;;</span><br></pre></td></tr></table></figure></p><p>当需要加入其它表的时候需要<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Join&lt;Object,Object&gt; userInfo = root.join(&quot;userInfo&quot;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用jpa的Specification-实现动态复杂查询条件&quot;&gt;&lt;a href=&quot;#使用jpa的Specification-实现动态复杂查询条件&quot; class=&quot;headerlink&quot; title=&quot;使用jpa的Specification 实现动态复杂查询条件&quot;&gt;
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="jpa" scheme="http://yoursite.com/tags/jpa/"/>
    
  </entry>
  
  <entry>
    <title>一个程序的运行流程</title>
    <link href="http://yoursite.com/2019/04/03/%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/04/03/一个程序的运行流程/</id>
    <published>2019-04-03T14:40:00.000Z</published>
    <updated>2019-09-03T14:45:52.281Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一个程序的运行过程"><a href="#一个程序的运行过程" class="headerlink" title="一个程序的运行过程"></a>一个程序的运行过程</h1><blockquote><p>在某个地方看见如下的一个程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String [] args)&#123;</span><br><span class="line">        System.out.println(new B().getValue());</span><br><span class="line">    &#125;</span><br><span class="line">    static class A&#123;</span><br><span class="line">        protected int value;</span><br><span class="line">        public A(int v)&#123;</span><br><span class="line">            setValue(v);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setValue(int v)&#123;</span><br><span class="line">            this.value = v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int getValue()&#123;</span><br><span class="line">            try&#123;</span><br><span class="line">                value++;</span><br><span class="line">                return value; 的return;</span><br><span class="line">            &#125; catch(Exception e) &#123;</span><br><span class="line">                System.out.println(e.toString());</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                this.setValue(value);</span><br><span class="line">                System.out.println(value);</span><br><span class="line">            &#125;</span><br><span class="line">            return value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class B extends A&#123;</span><br><span class="line">        public  B()&#123;</span><br><span class="line">            super(5);</span><br><span class="line">            setValue(getValue() - 3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void setValue(int v)&#123;</span><br><span class="line">            super.setValue(2*v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>程序最终将会输出什么?</p><ol><li>newB().getValue() 创建B对象 同时调用B对象的构造方法来创建B对象</li><li>super(5)调用父类的构造方法 B有对set方法的重写  v = 10</li><li>setValue(getValue() - 3) 由于B没有get方法 调用A的get方法 先++ 得到   v = 11</li><li>返回此时的v值（即存入临时栈中）</li><li>执行finally块 调用B的set 得到 v = 22  <strong>输出</strong></li><li>执行get - 3 此时的v值为之前return的值 也就是 11  得到    v = 8</li><li>执行B的set 得到 v = 16 </li><li>执行main 新建B对象的 get 方法  也就是B父类的get方法  ++得到  v = 17 同样return存入临时栈</li><li>执行finally块  v = 34  <strong>输出</strong></li><li>打印main函数 v = 17 <strong>输出</strong></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一个程序的运行过程&quot;&gt;&lt;a href=&quot;#一个程序的运行过程&quot; class=&quot;headerlink&quot; title=&quot;一个程序的运行过程&quot;&gt;&lt;/a&gt;一个程序的运行过程&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在某个地方看见如下的一个程序&lt;br&gt;&lt;figure cla
      
    
    </summary>
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java程序" scheme="http://yoursite.com/tags/java%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring IOC 与 DI</title>
    <link href="http://yoursite.com/2019/01/03/Spring-IOC-%E4%B8%8E-DI/"/>
    <id>http://yoursite.com/2019/01/03/Spring-IOC-与-DI/</id>
    <published>2019-01-03T15:00:21.000Z</published>
    <updated>2019-09-03T15:04:22.240Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-的IOC与DI"><a href="#Spring-的IOC与DI" class="headerlink" title="Spring 的IOC与DI"></a>Spring 的IOC与DI</h1><h3 id="分享Bromon的blog上对IoC与DI浅显易懂的讲解"><a href="#分享Bromon的blog上对IoC与DI浅显易懂的讲解" class="headerlink" title="分享Bromon的blog上对IoC与DI浅显易懂的讲解"></a>分享Bromon的blog上对IoC与DI浅显易懂的讲解</h3><p>1、IoC(控制反转)<br>　　首先想说说IoC（Inversion of Control，控制反转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。</p><p>　　那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。</p><p>2、DI(依赖注入)<br>　　IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。　　</p><h3 id="我对IOC与DI的理解"><a href="#我对IOC与DI的理解" class="headerlink" title="我对IOC与DI的理解"></a>我对IOC与DI的理解</h3><pre><code>IOC 控制反转，是Spring提供的一个工厂，我们将项目的对象提前创建好（有时是需要的时候才创建），每次需要使用对象时，调用方不用自主生成对象，而是将控制权交给了Spring容器DI 依赖注入 就是在Spring创建对象的时候将对象属性依赖进去，不用再次的去对每个属性设置值。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-的IOC与DI&quot;&gt;&lt;a href=&quot;#Spring-的IOC与DI&quot; class=&quot;headerlink&quot; title=&quot;Spring 的IOC与DI&quot;&gt;&lt;/a&gt;Spring 的IOC与DI&lt;/h1&gt;&lt;h3 id=&quot;分享Bromon的blog上对Io
      
    
    </summary>
    
      <category term="spring" scheme="http://yoursite.com/categories/spring/"/>
    
    
      <category term="IOC" scheme="http://yoursite.com/tags/IOC/"/>
    
  </entry>
  
</feed>
